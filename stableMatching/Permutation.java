import java.util.ArrayList;
import java.util.Arrays;

public class Permutation {
    private int n;
    private int k;
    private boolean allowEmptySpots;

    private long count;
    private int[] womenCounts;
    private int[] pairing;
    private boolean done;

    /**
     * Initialize a permutation which will select pairings of women to men.
     * There should be at most p pairings. No pairing should be used more than
     * once. No woman should be used more than once.
     * 
     * @param n
     *            Number of women.
     * @param m
     *            Number of men available.
     */
    public Permutation(int n, int k, boolean allowEmptyPositions) {
        this.n = n;
        this.k = k;
        this.allowEmptySpots = allowEmptyPositions;

        this.count = 0;

        this.womenCounts = new int[this.n];
        Arrays.fill(this.womenCounts, 0);
        this.pairing = new int[this.k];

        if (allowEmptyPositions) {
            Arrays.fill(this.pairing, -1);
        } else {
            Arrays.fill(this.pairing, 0);
            this.womenCounts[0] = this.pairing.length;
        }

        this.done = false;
    }

    public Permutation(int n, int k) {
        this(n, k, false);
    }

	/**
	 * Return the next permutation as a Matching object, representing a solution
	 * to the Stable Matching problem contained in data.
	 * 
	 * @param data
	 *            The Matching object containing the problem to solve.
	 * @return The next candidate solution to the problem.
	 */
    public Matching getNextMatching(Matching data) {
        int[] pairing = getNextPairing();
        if (pairing == null) {
            return null;
        }

        Matching matching = convertPairingToMatching(data, pairing);
        return matching;
    }

    /**
     * Return a Matching (StableMarriage candidate) constructed from the int[]
     * generated by getNextPairing().
     * 
     * @param data
     *            The Matching object containing the problem to solve.
     * @param pairing
     *            The candidate solution as generated by getNextPairing.
     * @return The Matching corresponding to the provided pairing.
     */
    private Matching convertPairingToMatching(Matching data, int[] pairing) {

        int m = data.getMenCount();
        int n = data.getWomenCount();
        ArrayList<Integer> men_slots = data.getMenSlots();

        int pairing_index = 0;
        ArrayList<Integer> woman_matching = new ArrayList<Integer>(0);
        for (int i = 0; i < n; i++) {
            woman_matching.add(-1);
        }

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < men_slots.get(i); j++) {
                if (pairing[pairing_index] != -1) {
                    woman_matching.set(pairing[pairing_index], i);
                }

                if (pairing_index == pairing.length) {
                    break;
                }

                pairing_index++;
            }
        }

        return new Matching(data, woman_matching);
    }

    /**
     * Select the next pairing in "ascending order." Each woman can be
     * assigned to at most one spot, and each spot can be assigned to at most
     * one woman, and there are more women than there are spots. Therefore,
     * the the length of the returned array will be k, and each spot in the
     * array will contain the index of woman which will fill that spot.
     * 
     * Values for the women range from 0 to n-1, so let the counting system
     * be a base-n counting system. Each spot in the array must contain an
     * integer in [0,n-1) and when a position in the array wraps around, the
     * next highest position is incremented.
     * 
     * Keep track of the number of instances of a given woman's number are
     * present in the pairing. A pairing is only valid if each woman is paired
     * with a position at most 1 time.
     */
    private int[] getNextPairing() {
        if (done) {
            return null;
        }

        count++;

        do {
            incrementPairing();
        } while (!isValidPairing());

        int[] nextPairing = new int[pairing.length];
        System.arraycopy(pairing, 0, nextPairing, 0, pairing.length);
        return nextPairing;
    }

    private boolean isValidPairing() {
        for (int x : womenCounts) {
            if (x > 1) {
                return false;
            }
        }
        return true;
    }

    /**
     * Increment one position of the pairing and update arrays appropriately.
     * 
     * @param index
     *            The index of the array to increment.
     */
    private void incrementPairing(int index) {
        if (index == 0) {
            count++;
        }

        if (index >= pairing.length) {
            done = true;
            return;
        }

        removeWoman(pairing[index]);

        // update women in matching
        pairing[index]++;
        if (pairing[index] >= n) {
            if (allowEmptySpots) {
                pairing[index] = -1;
            } else {
                pairing[index] = 0;
            }

            incrementPairing(index + 1);
        }

        addWoman(pairing[index]);
    }

    private void incrementPairing() {
        incrementPairing(0);
    }

    private void updateWoman(int woman, int update) {
        if (woman == -1 || woman >= n) {
            return;
        }

        womenCounts[woman] += update;
    }

    private void removeWoman(int woman) {
        updateWoman(woman, -1);
    }

    private void addWoman(int woman) {
        updateWoman(woman, 1);
    }
}
